(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common/http'), require('rxjs/Rx'), require('@angular/common')) :
	typeof define === 'function' && define.amd ? define('angular-azure-blob-service', ['exports', '@angular/core', '@angular/common/http', 'rxjs/Rx', '@angular/common'], factory) :
	(factory((global['angular-azure-blob-service'] = {}),global.ng.core,global.ng.common.http,global.Rx,global.ng.common));
}(this, (function (exports,core,http,Rx,common) { 'use strict';

var BlobService = /** @class */ (function () {
    function BlobService(http$$1) {
        this.http = http$$1;
    }
    BlobService.prototype.generateBlobUrl = function (params, filename, useAzureStorageEmulator, azureStorageEmulatorBaseUrl) {
        if (useAzureStorageEmulator === void 0) { useAzureStorageEmulator = false; }
        if (azureStorageEmulatorBaseUrl === void 0) { azureStorageEmulatorBaseUrl = ''; }
        var url = useAzureStorageEmulator ? azureStorageEmulatorBaseUrl : "https://" + params.storageAccount + ".blob.core.windows.net";
        return url + "/" + params.containerName + "/" + filename;
    };
    BlobService.prototype.uploadFileInBlocks = function (reader, state) {
        if (!state.cancelled) {
            if (state.totalBytesRemaining > 0) {
                var fileContent = state.file.slice(state.currentFilePointer, state.currentFilePointer + state.maxBlockSize);
                var blockId = state.blockIdPrefix + this.prependZeros(state.blockIds.length, 6);
                state.blockIds.push(btoa(blockId));
                reader.readAsArrayBuffer(fileContent);
                state.currentFilePointer += state.maxBlockSize;
                state.totalBytesRemaining -= state.maxBlockSize;
                if (state.totalBytesRemaining < state.maxBlockSize) {
                    state.maxBlockSize = state.totalBytesRemaining;
                }
            }
            else {
                this.commitBlockList(state);
            }
        }
    };
    BlobService.prototype.commitBlockList = function (state) {
        var uri = state.fileUrl + '&comp=blocklist';
        var headers = new http.HttpHeaders({ 'x-ms-blob-content-type': state.file.type });
        var requestBody = '<?xml version=\'1.0\' encoding=\'utf-8\'?><BlockList>';
        for (var i = 0; i < state.blockIds.length; i++) {
            requestBody += '<Latest>' + state.blockIds[i] + '</Latest>';
        }
        requestBody += '</BlockList>';
        this.http.put(uri, requestBody, { headers: headers, responseType: 'text' })
            .subscribe(function (elem) {
            if (state.complete) {
                state.complete();
            }
        }, function (err) {
            console.log({ error: err });
        });
    };
    BlobService.prototype.initializeState = function (config) {
        var blockSize = BlobService.DefaultBlockSize;
        if (config.blockSize) {
            blockSize = config.blockSize;
        }
        var maxBlockSize = blockSize;
        var numberOfBlocks = 1;
        var file = config.file;
        var fileSize = file.size;
        if (fileSize < blockSize) {
            maxBlockSize = fileSize;
        }
        if (fileSize % maxBlockSize === 0) {
            numberOfBlocks = fileSize / maxBlockSize;
        }
        else {
            numberOfBlocks = fileSize / maxBlockSize + 1;
        }
        return {
            maxBlockSize: maxBlockSize,
            numberOfBlocks: numberOfBlocks,
            totalBytesRemaining: fileSize,
            currentFilePointer: 0,
            blockIds: new Array(),
            blockIdPrefix: 'block-',
            bytesUploaded: 0,
            submitUri: null,
            file: file,
            baseUrl: config.baseUrl,
            sasToken: config.sasToken,
            fileUrl: config.baseUrl + config.sasToken,
            progress: config.progress,
            complete: config.complete,
            error: config.error,
            cancelled: false
        };
    };
    BlobService.prototype.upload = function (config) {
        var _this = this;
        var state = this.initializeState(config);
        var reader = new FileReader();
        reader.onloadend = function (evt) {
            if (evt.target.readyState === 2 && !state.cancelled) {
                var uri = state.fileUrl + '&comp=block&blockid=' + state.blockIds[state.blockIds.length - 1];
                var requestData = evt.target.result;
                var requestData2_1 = new Uint8Array(evt.target.result);
                var headers = new http.HttpHeaders({ 'x-ms-blob-type': 'BlockBlob', 'Content-Type': 'application/octet-stream' });
                _this.http.put(uri, requestData, { headers: headers, responseType: 'text' })
                    .subscribe(function (elem) {
                    state.bytesUploaded += requestData2_1.length;
                    var percentComplete = Math.round((state.bytesUploaded / state.file.size) * 1000) / 10;
                    if (state.progress) {
                        state.progress(percentComplete);
                    }
                    _this.uploadFileInBlocks(reader, state);
                }, function (err) {
                    console.log({ error: err });
                });
            }
        };
        this.uploadFileInBlocks(reader, state);
        return {
            cancel: function () {
                state.cancelled = true;
            }
        };
    };
    BlobService.prototype.prependZeros = function (number, length) {
        var str = '' + number;
        while (str.length < length) {
            str = '0' + str;
        }
        return str;
    };
    BlobService.prototype.handleAngularJsonBug = function (error, cb) {
        var JsonParseError = 'Http failure during parsing for';
        var matches = error.message.match(new RegExp(JsonParseError, 'ig'));
        if ((error.status === 200 || error.status === 201) && matches.length === 1) {
            return Rx.Observable.empty();
        }
        else {
            cb();
        }
    };
    return BlobService;
}());
BlobService.DefaultBlockSize = 1024 * 32;
BlobService.decorators = [
    { type: core.Injectable },
];
BlobService.ctorParameters = function () { return [
    { type: http.HttpClient, },
]; };
var BlobModule = /** @class */ (function () {
    function BlobModule() {
    }
    BlobModule.forRoot = function () {
        return {
            ngModule: BlobModule,
            providers: [
                BlobService
            ]
        };
    };
    return BlobModule;
}());
BlobModule.decorators = [
    { type: core.NgModule, args: [{
                imports: [
                    common.CommonModule,
                    http.HttpClientModule
                ],
                declarations: [],
                exports: []
            },] },
];
BlobModule.ctorParameters = function () { return []; };

exports.BlobService = BlobService;
exports.BlobModule = BlobModule;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=angular-azure-blob-service.umd.js.map
